<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <script src="https://unpkg.com/@hpcc-js/wasm@0.3.6/dist/index.min.js"></script>
  <script src="https://unpkg.com/d3-graphviz@3.0.0/build/d3-graphviz.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bibtex-parse-js@0.0.24/bibtexParse.js" integrity="sha256-v968ksKZppVegXgenPlIK/9mN80zJo1PXOCu+ao0lKw=" crossorigin="anonymous"></script>
</head>

<body>
  <h1>
    Virtual Machine Research Overview
  </h1>

  <p>
    <strong>Disclaimer:</strong> It's not assumed this overview is complete in any way.
  </p>
  <p>
  <a href="https://github.com/eregon/virtual-machines-research-graph/edit/master/graph.dot">Edit on GitHub</a>
  </p>
<div id="graph" style="text-align: center;"></div>
<script>
//@ts-check
'use strict';

function extractConcepts(p, paper, concepts) {
  if (!paper.entryTags['vm:concepts']) {
    return;
  }

  const cs = paper.entryTags['vm:concepts'].split(',');
  for (const c of cs) {
    if (c.trim().length > 0) {
      const concept = {
        id: getConceptId(c),
        name: c.trim()
      };

      concepts[concept.id] = concept;
      if (!p.concepts) {
        p.concepts = [];
      }
      p.concepts.push(concept);

      if (!p.edges) {
        p.edges = [];
      }
      p.edges.push({
        type: 'concept',
        target: concept.id,
        label: null
      });
    }
  }
}

function extractEdges(p, paper) {
  for (const key of Object.keys(paper.entryTags)) {
    if (key.startsWith('vm:edge:')) {
      const edgeName = key.replace('vm:edge:', '');
      const edges = paper.entryTags[key].split(';');

      for (const e of edges) {
        const trimmed = e.trim();
        const idxFirstSpace = trimmed.indexOf(' ');
        const targetId = idxFirstSpace === -1 ? trimmed : trimmed.substr(0, idxFirstSpace);
        let label = idxFirstSpace === -1 ? null : trimmed.substr(idxFirstSpace).trim();
        if (label && label.length == 0) {
          label = null;
        }

        if (!p.edges) {
          p.edges = [];
        }
        p.edges.push({
          type: edgeName,
          target: targetId,
          label: label
        });
      }
    }
  }
}

function getPapersAndConcepts(entries) {
  const papers = [];
  const concepts = {};

  for (const paper of entries) {
    if (paper.entryType === "COMMENT") {
      continue;
    }

    if (paper.entryType === "concept") {
      let concept = concepts[paper.citationKey];
      if (!concept) {
        concept = {
          id: getConceptId(paper.citationKey),
          name: paper.citationKey.trim()
        };
        concepts[paper.citationKey] = concept;
      }

      const name = paper.entryTags['vm:shortTitle'];
      if (name && name.trim()) {
        concept.name = name.trim();
      }

      extractConcepts(concept, paper, concepts);
      continue;
    }

    const p = {
      id: paper.citationKey,
      shortTitle: paper.entryTags['vm:shortTitle'],
      venue: paper.entryTags.series,
      title: paper.entryTags.title,
      url: paper.entryTags.url,
      year: paper.entryTags.year
    };

    // check completeness
    for (const [key, value] of Object.entries(p)) {
      if (!value) {
        console.warn(`${paper.citationKey} misses ${key}`);
      }
    }

    extractConcepts(p, paper, concepts);
    extractEdges(p, paper);

    papers.push(p);
  }
  return {papers, concepts};
}

function getConceptId(str) {
  return str.trim().replace(/\s/g,'');
}

function renderConcepts(concepts) {
  let result = '';
  for (const c of Object.values(concepts)) {
    result += `
      "${c.id}" [
        label = "${c.name}",
        shape = "oval"
      ]
    `;
  }
  return result;
}

function renderPapers(papers) {
  let result = '';
  for (const paper of papers) {
    const graphizEscapedUrl = paper.url.replace(/&(?!amp;)/gm, '&amp;');
    result += `
      "${paper.id}" [
        label = "${paper.shortTitle} (${paper.venue})",
        tooltip = "${paper.title}",
        URL = "${graphizEscapedUrl}"
      ]
    `;
  }

  return result;
}

function renderEdges(papers) {
  const edgeTypes = {
    'default': 'solid',
    'concept': 'dotted',
    'extends': 'solid',
    'uses':    'dashed'
  };

  const conceptEdges = new Map();
  const nonConceptEdges = new Map();

  for (const paper of papers) {
    if (!paper.edges) {
      continue;
    }

    for (const edge of paper.edges) {
      let style = edgeTypes[edge.type];
      if (!style) {
        style = edgeTypes['default'];
      }

      let label = '';
      if (edge.label) {
        label = `label = "${edge.label}",`
      }

      const edgeViz = `
        "${edge.target}" -> "${paper.id}" [
          ${label}
          style = "${style}"
        ]\n`;


      const edgeId = `${edge.target}" -> "${paper.id}"`;
      if (edge.type === 'concept') {
        if (conceptEdges.has(edgeId)) {
          console.log(`Redundant edge: ${edgeId}`);
        }
        conceptEdges.set(edgeId, edgeViz);
      } else {
        if (!nonConceptEdges.has(edgeId)) {
          nonConceptEdges.set(edgeId, []);
        }
        nonConceptEdges.get(edgeId).push(edgeViz);
      }
    }
  }

  let result = '';
  for (const edgeList of nonConceptEdges.values()) {
    for (const edgeViz of edgeList) {
      result += edgeViz;
    }
  }
  for (const [edgeId, edgeViz] of conceptEdges.entries()) {
    // Avoid drawing a redundant edge based on concept relationship
    if (!nonConceptEdges.has(edgeId)) {
      result += edgeViz;
    }
  }
  return result;
}

function renderToDot(papers, concepts) {
  let result = `digraph G {
  node [shape = "box"]`;

  result += renderConcepts(concepts);
  result += renderPapers(papers);

  const edges = Object.values(concepts).concat(papers);
  result += renderEdges(edges);

  result += '}';
  return result;
}

function convertToDot(bibtex) {
  const entries = bibtexParse.toJSON(bibtex);
  const {papers, concepts} = getPapersAndConcepts(entries);
  return renderToDot(papers, concepts);
}


// const dataPromise = fetch('https://raw.githubusercontent.com/eregon/virtual-machines-research-graph/master/vm.bib')
//   .then((response) => {
//     return response.text();
//   });

const dataPromise = fetch('vm.bib')
  .then((response) => {
    return response.text();
  });

var dotIndex = 0;
var graphviz = d3.select("#graph").graphviz()
    .transition(function () {
        return d3.transition("main")
            .ease(d3.easeLinear)
            .delay(100)
            .duration(500);
    })
    .logEvents(true)
    .on("initEnd", triggerRender);

let triggerRenderResolve;
const triggerRenderP = new Promise(function(resolve, reject) {
  triggerRenderResolve = resolve;
});

function triggerRender() {
  triggerRenderResolve();
}

Promise.all([dataPromise, triggerRenderP]).then(function(values) {
  const dot = convertToDot(values[0]);
  graphviz.renderDot(dot);
});
</script>
</html>